# JsonPathParser

## Summary

| Key             | Value                          |
| :-------------- | :----------------------------- |
| Class           | `JsonPathParser`               |
| Assembly        | `BinaryDataDecoders.Text.Json` |
| Coveredlines    | `541`                          |
| Uncoveredlines  | `125`                          |
| Coverablelines  | `666`                          |
| Totallines      | `1167`                         |
| Linecoverage    | `81.2`                         |
| Coveredbranches | `83`                           |
| Totalbranches   | `111`                          |
| Branchcoverage  | `74.7`                         |

## Metrics

| Complexity | Lines | Branches | Name                  |
| :--------- | :---- | :------- | :-------------------- |
| 2          | 100   | 100      | `cctor`               |
| 1          | 0     | 100      | `get_Vocabulary`      |
| 1          | 0     | 100      | `get_GrammarFileName` |
| 1          | 0     | 100      | `get_RuleNames`       |
| 1          | 0     | 100      | `get_SerializedAtn`   |
| 1          | 100   | 100      | `ctor`                |
| 1          | 100   | 100      | `ctor`                |
| 1          | 100   | 100      | `path`                |
| 1          | 0     | 100      | `Eof`                 |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 1          | 64.28 | 100      | `start`               |
| 1          | 100   | 100      | `pathBase`            |
| 1          | 100   | 100      | `sequence`            |
| 1          | 100   | 100      | `function`            |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 4          | 72.72 | 75.00    | `path`                |
| 1          | 100   | 100      | `ROOT`                |
| 1          | 100   | 100      | `RELATIVE`            |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 4          | 66.66 | 75.00    | `pathBase`            |
| 1          | 100   | 100      | `sequenceItem`        |
| 1          | 100   | 100      | `sequence`            |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 2          | 70.58 | 100      | `sequence`            |
| 1          | 100   | 100      | `WILDCARD`            |
| 1          | 100   | 100      | `identity`            |
| 1          | 100   | 100      | `bracket`             |
| 1          | 100   | 100      | `filter`              |
| 1          | 100   | 100      | `function`            |
| 1          | 0     | 100      | `PATH_SEPERATOR`      |
| 1          | 100   | 100      | `DESCENDANTS`         |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 17         | 83.78 | 82.35    | `sequenceItem`        |
| 1          | 100   | 100      | `WILDCARD`            |
| 1          | 100   | 100      | `NUMBER`              |
| 1          | 0     | 100      | `NUMBER`              |
| 1          | 100   | 100      | `string`              |
| 1          | 0     | 100      | `string`              |
| 1          | 100   | 100      | `range`               |
| 1          | 100   | 100      | `function`            |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 10         | 91.07 | 90.0     | `bracket`             |
| 1          | 100   | 100      | `query`               |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 1          | 70.58 | 100      | `filter`              |
| 1          | 0     | 100      | `NUMBER`              |
| 1          | 0     | 100      | `NUMBER`              |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 6          | 82.75 | 100      | `range`               |
| 1          | 100   | 100      | `path`                |
| 1          | 100   | 100      | `string`              |
| 1          | 100   | 100      | `NUMBER`              |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 6          | 75.00 | 83.33    | `operand`             |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 1          | 100   | 100      | `ctor`                |
| 1          | 100   | 100      | `CopyFrom`            |
| 1          | 100   | 100      | `LOGICAL`             |
| 1          | 0     | 100      | `query`               |
| 1          | 0     | 100      | `query`               |
| 1          | 100   | 100      | `ctor`                |
| 2          | 66.66 | 50.0     | `Accept`              |
| 1          | 100   | 100      | `RELATIONAL`          |
| 1          | 0     | 100      | `operand`             |
| 1          | 0     | 100      | `operand`             |
| 1          | 100   | 100      | `ctor`                |
| 2          | 66.66 | 50.0     | `Accept`              |
| 1          | 100   | 100      | `path`                |
| 1          | 100   | 100      | `ctor`                |
| 2          | 66.66 | 50.0     | `Accept`              |
| 1          | 0     | 100      | `query`               |
| 14         | 87.75 | 92.85    | `query`               |
| 1          | 100   | 100      | `IDENTITY`            |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 1          | 61.53 | 100      | `identity`            |
| 1          | 100   | 100      | `QUOTED_STRING`       |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 1          | 61.53 | 100      | `string`              |
| 1          | 100   | 100      | `identity`            |
| 1          | 100   | 100      | `functionParameter`   |
| 1          | 0     | 100      | `functionParameter`   |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 6          | 84.37 | 100      | `function`            |
| 1          | 100   | 100      | `operand`             |
| 1          | 100   | 100      | `pathBase`            |
| 1          | 100   | 100      | `DECIMAL`             |
| 1          | 100   | 100      | `ctor`                |
| 1          | 0     | 100      | `get_RuleIndex`       |
| 2          | 66.66 | 50.0     | `Accept`              |
| 4          | 77.27 | 100      | `functionParameter`   |
| 2          | 0     | 0        | `Sempred`             |
| 2          | 0     | 0        | `query_sempred`       |

## Files

## File - /home/runner/work/BinaryDataDecoders/BinaryDataDecoders/src/BinaryDataDecoders.Text.Json/obj/Release/netstandard2.1/JsonPathParser.cs

```CSharp
〰1:   //------------------------------------------------------------------------------
〰2:   // <auto-generated>
〰3:   //     This code was generated by a tool.
〰4:   //     ANTLR Version: 4.8
〰5:   //
〰6:   //     Changes to this file may cause incorrect behavior and will be lost if
〰7:   //     the code is regenerated.
〰8:   // </auto-generated>
〰9:   //------------------------------------------------------------------------------
〰10:  
〰11:  // Generated from /home/runner/work/BinaryDataDecoders/BinaryDataDecoders/src/BinaryDataDecoders.Text.Json/JsonPath/Parser/JsonPath.g4 by ANTLR 4.8
〰12:  
〰13:  // Unreachable code detected
〰14:  #pragma warning disable 0162
〰15:  // The variable '...' is assigned but its value is never used
〰16:  #pragma warning disable 0219
〰17:  // Missing XML comment for publicly visible type or member '...'
〰18:  #pragma warning disable 1591
〰19:  // Ambiguous reference in cref attribute
〰20:  #pragma warning disable 419
〰21:  
〰22:  using System;
〰23:  using System.IO;
〰24:  using System.Text;
〰25:  using System.Diagnostics;
〰26:  using System.Collections.Generic;
〰27:  using Antlr4.Runtime;
〰28:  using Antlr4.Runtime.Atn;
〰29:  using Antlr4.Runtime.Misc;
〰30:  using Antlr4.Runtime.Tree;
〰31:  using DFA = Antlr4.Runtime.Dfa.DFA;
〰32:  
〰33:  [System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
〰34:  [System.CLSCompliant(false)]
〰35:  public partial class JsonPathParser : Parser {
〰36:  	protected static DFA[] decisionToDFA;
✔37:  	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
〰38:  	public const int
〰39:  		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, QUOTED_STRING=9,
〰40:  		LOGICAL=10, RELATIONAL=11, PATH_SEPERATOR=12, WILDCARD=13, DESCENDANTS=14,
〰41:  		RELATIVE=15, ROOT=16, IDENTITY=17, NUMBER=18, DECIMAL=19, WS=20;
〰42:  	public const int
〰43:  		RULE_start = 0, RULE_path = 1, RULE_pathBase = 2, RULE_sequence = 3, RULE_sequenceItem = 4,
〰44:  		RULE_bracket = 5, RULE_filter = 6, RULE_range = 7, RULE_operand = 8, RULE_query = 9,
〰45:  		RULE_identity = 10, RULE_string = 11, RULE_function = 12, RULE_functionParameter = 13;
✔46:  	public static readonly string[] ruleNames = {
✔47:  		"start", "path", "pathBase", "sequence", "sequenceItem", "bracket", "filter",
✔48:  		"range", "operand", "query", "identity", "string", "function", "functionParameter"
✔49:  	};
〰50:  
✔51:  	private static readonly string[] _LiteralNames = {
✔52:  		null, "'['", "']'", "','", "'?('", "')'", "':'", "'()'", "'('", null,
✔53:  		null, null, "'.'", "'*'", "'..'", "'@'", "'$'"
✔54:  	};
✔55:  	private static readonly string[] _SymbolicNames = {
✔56:  		null, null, null, null, null, null, null, null, null, "QUOTED_STRING",
✔57:  		"LOGICAL", "RELATIONAL", "PATH_SEPERATOR", "WILDCARD", "DESCENDANTS",
✔58:  		"RELATIVE", "ROOT", "IDENTITY", "NUMBER", "DECIMAL", "WS"
✔59:  	};
✔60:  	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);
〰61:  
〰62:  	[NotNull]
〰63:  	public override IVocabulary Vocabulary
〰64:  	{
〰65:  		get
〰66:  		{
‼67:  			return DefaultVocabulary;
〰68:  		}
〰69:  	}
〰70:  
‼71:  	public override string GrammarFileName { get { return "JsonPath.g4"; } }
〰72:  
‼73:  	public override string[] RuleNames { get { return ruleNames; } }
〰74:  
‼75:  	public override string SerializedAtn { get { return new string(_serializedATN); } }
〰76:  
〰77:  	static JsonPathParser() {
✔78:  		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
✔79:  		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
✔80:  			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
〰81:  		}
✔82:  	}
〰83:  
✔84:  		public JsonPathParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }
〰85:  
〰86:  		public JsonPathParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
✔87:  		: base(input, output, errorOutput)
〰88:  	{
✔89:  		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
✔90:  	}
〰91:  
〰92:  	public partial class StartContext : ParserRuleContext {
〰93:  		public PathContext path() {
✔94:  			return GetRuleContext<PathContext>(0);
〰95:  		}
‼96:  		public ITerminalNode Eof() { return GetToken(JsonPathParser.Eof, 0); }
〰97:  		public StartContext(ParserRuleContext parent, int invokingState)
✔98:  			: base(parent, invokingState)
〰99:  		{
✔100: 		}
‼101: 		public override int RuleIndex { get { return RULE_start; } }
〰102: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔103: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠104: 			if (typedVisitor != null) return typedVisitor.VisitStart(this);
‼105: 			else return visitor.VisitChildren(this);
〰106: 		}
〰107: 	}
〰108: 
〰109: 	[RuleVersion(0)]
〰110: 	public StartContext start() {
✔111: 		StartContext _localctx = new StartContext(Context, State);
✔112: 		EnterRule(_localctx, 0, RULE_start);
〰113: 		try {
✔114: 			EnterOuterAlt(_localctx, 1);
〰115: 			{
✔116: 			State = 28; path();
✔117: 			State = 29; Match(Eof);
〰118: 			}
✔119: 		}
‼120: 		catch (RecognitionException re) {
‼121: 			_localctx.exception = re;
‼122: 			ErrorHandler.ReportError(this, re);
‼123: 			ErrorHandler.Recover(this, re);
‼124: 		}
〰125: 		finally {
✔126: 			ExitRule();
✔127: 		}
✔128: 		return _localctx;
〰129: 	}
〰130: 
〰131: 	public partial class PathContext : ParserRuleContext {
〰132: 		public PathBaseContext pathBase() {
✔133: 			return GetRuleContext<PathBaseContext>(0);
〰134: 		}
〰135: 		public SequenceContext sequence() {
✔136: 			return GetRuleContext<SequenceContext>(0);
〰137: 		}
〰138: 		public FunctionContext function() {
✔139: 			return GetRuleContext<FunctionContext>(0);
〰140: 		}
〰141: 		public PathContext(ParserRuleContext parent, int invokingState)
✔142: 			: base(parent, invokingState)
〰143: 		{
✔144: 		}
‼145: 		public override int RuleIndex { get { return RULE_path; } }
〰146: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔147: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠148: 			if (typedVisitor != null) return typedVisitor.VisitPath(this);
‼149: 			else return visitor.VisitChildren(this);
〰150: 		}
〰151: 	}
〰152: 
〰153: 	[RuleVersion(0)]
〰154: 	public PathContext path() {
✔155: 		PathContext _localctx = new PathContext(Context, State);
✔156: 		EnterRule(_localctx, 2, RULE_path);
〰157: 		try {
✔158: 			State = 35;
✔159: 			ErrorHandler.Sync(this);
⚠160: 			switch (TokenStream.LA(1)) {
〰161: 			case RELATIVE:
〰162: 			case ROOT:
✔163: 				EnterOuterAlt(_localctx, 1);
〰164: 				{
✔165: 				State = 31; pathBase();
✔166: 				State = 32; sequence();
〰167: 				}
✔168: 				break;
〰169: 			case IDENTITY:
✔170: 				EnterOuterAlt(_localctx, 2);
〰171: 				{
✔172: 				State = 34; function();
〰173: 				}
✔174: 				break;
〰175: 			default:
‼176: 				throw new NoViableAltException(this);
〰177: 			}
✔178: 		}
‼179: 		catch (RecognitionException re) {
‼180: 			_localctx.exception = re;
‼181: 			ErrorHandler.ReportError(this, re);
‼182: 			ErrorHandler.Recover(this, re);
‼183: 		}
〰184: 		finally {
✔185: 			ExitRule();
✔186: 		}
✔187: 		return _localctx;
〰188: 	}
〰189: 
〰190: 	public partial class PathBaseContext : ParserRuleContext {
✔191: 		public ITerminalNode ROOT() { return GetToken(JsonPathParser.ROOT, 0); }
✔192: 		public ITerminalNode RELATIVE() { return GetToken(JsonPathParser.RELATIVE, 0); }
〰193: 		public PathBaseContext(ParserRuleContext parent, int invokingState)
✔194: 			: base(parent, invokingState)
〰195: 		{
✔196: 		}
‼197: 		public override int RuleIndex { get { return RULE_pathBase; } }
〰198: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔199: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠200: 			if (typedVisitor != null) return typedVisitor.VisitPathBase(this);
‼201: 			else return visitor.VisitChildren(this);
〰202: 		}
〰203: 	}
〰204: 
〰205: 	[RuleVersion(0)]
〰206: 	public PathBaseContext pathBase() {
✔207: 		PathBaseContext _localctx = new PathBaseContext(Context, State);
✔208: 		EnterRule(_localctx, 4, RULE_pathBase);
〰209: 		int _la;
〰210: 		try {
✔211: 			EnterOuterAlt(_localctx, 1);
〰212: 			{
✔213: 			State = 37;
✔214: 			_la = TokenStream.LA(1);
⚠215: 			if ( !(_la==RELATIVE || _la==ROOT) ) {
‼216: 			ErrorHandler.RecoverInline(this);
〰217: 			}
〰218: 			else {
✔219: 				ErrorHandler.ReportMatch(this);
✔220: 			    Consume();
〰221: 			}
〰222: 			}
✔223: 		}
‼224: 		catch (RecognitionException re) {
‼225: 			_localctx.exception = re;
‼226: 			ErrorHandler.ReportError(this, re);
‼227: 			ErrorHandler.Recover(this, re);
‼228: 		}
〰229: 		finally {
✔230: 			ExitRule();
✔231: 		}
✔232: 		return _localctx;
〰233: 	}
〰234: 
〰235: 	public partial class SequenceContext : ParserRuleContext {
〰236: 		public SequenceItemContext sequenceItem() {
✔237: 			return GetRuleContext<SequenceItemContext>(0);
〰238: 		}
〰239: 		public SequenceContext sequence() {
✔240: 			return GetRuleContext<SequenceContext>(0);
〰241: 		}
〰242: 		public SequenceContext(ParserRuleContext parent, int invokingState)
✔243: 			: base(parent, invokingState)
〰244: 		{
✔245: 		}
‼246: 		public override int RuleIndex { get { return RULE_sequence; } }
〰247: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔248: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠249: 			if (typedVisitor != null) return typedVisitor.VisitSequence(this);
‼250: 			else return visitor.VisitChildren(this);
〰251: 		}
〰252: 	}
〰253: 
〰254: 	[RuleVersion(0)]
〰255: 	public SequenceContext sequence() {
✔256: 		SequenceContext _localctx = new SequenceContext(Context, State);
✔257: 		EnterRule(_localctx, 6, RULE_sequence);
〰258: 		try {
✔259: 			EnterOuterAlt(_localctx, 1);
〰260: 			{
✔261: 			State = 39; sequenceItem();
✔262: 			State = 41;
✔263: 			ErrorHandler.Sync(this);
✔264: 			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
〰265: 			case 1:
〰266: 				{
✔267: 				State = 40; sequence();
〰268: 				}
〰269: 				break;
〰270: 			}
〰271: 			}
✔272: 		}
‼273: 		catch (RecognitionException re) {
‼274: 			_localctx.exception = re;
‼275: 			ErrorHandler.ReportError(this, re);
‼276: 			ErrorHandler.Recover(this, re);
‼277: 		}
〰278: 		finally {
✔279: 			ExitRule();
✔280: 		}
✔281: 		return _localctx;
〰282: 	}
〰283: 
〰284: 	public partial class SequenceItemContext : ParserRuleContext {
✔285: 		public ITerminalNode WILDCARD() { return GetToken(JsonPathParser.WILDCARD, 0); }
〰286: 		public IdentityContext identity() {
✔287: 			return GetRuleContext<IdentityContext>(0);
〰288: 		}
〰289: 		public BracketContext bracket() {
✔290: 			return GetRuleContext<BracketContext>(0);
〰291: 		}
〰292: 		public FilterContext filter() {
✔293: 			return GetRuleContext<FilterContext>(0);
〰294: 		}
〰295: 		public FunctionContext function() {
✔296: 			return GetRuleContext<FunctionContext>(0);
〰297: 		}
‼298: 		public ITerminalNode PATH_SEPERATOR() { return GetToken(JsonPathParser.PATH_SEPERATOR, 0); }
✔299: 		public ITerminalNode DESCENDANTS() { return GetToken(JsonPathParser.DESCENDANTS, 0); }
〰300: 		public SequenceItemContext(ParserRuleContext parent, int invokingState)
✔301: 			: base(parent, invokingState)
〰302: 		{
✔303: 		}
‼304: 		public override int RuleIndex { get { return RULE_sequenceItem; } }
〰305: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔306: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠307: 			if (typedVisitor != null) return typedVisitor.VisitSequenceItem(this);
‼308: 			else return visitor.VisitChildren(this);
〰309: 		}
〰310: 	}
〰311: 
〰312: 	[RuleVersion(0)]
〰313: 	public SequenceItemContext sequenceItem() {
✔314: 		SequenceItemContext _localctx = new SequenceItemContext(Context, State);
✔315: 		EnterRule(_localctx, 8, RULE_sequenceItem);
〰316: 		int _la;
〰317: 		try {
✔318: 			State = 54;
✔319: 			ErrorHandler.Sync(this);
⚠320: 			switch (TokenStream.LA(1)) {
〰321: 			case T__0:
〰322: 			case PATH_SEPERATOR:
〰323: 			case WILDCARD:
〰324: 			case IDENTITY:
✔325: 				EnterOuterAlt(_localctx, 1);
〰326: 				{
✔327: 				State = 44;
✔328: 				ErrorHandler.Sync(this);
✔329: 				_la = TokenStream.LA(1);
✔330: 				if (_la==PATH_SEPERATOR) {
〰331: 					{
✔332: 					State = 43; Match(PATH_SEPERATOR);
〰333: 					}
〰334: 				}
〰335: 
✔336: 				State = 51;
✔337: 				ErrorHandler.Sync(this);
✔338: 				switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
〰339: 				case 1:
〰340: 					{
✔341: 					State = 46; Match(WILDCARD);
〰342: 					}
✔343: 					break;
〰344: 				case 2:
〰345: 					{
✔346: 					State = 47; identity();
〰347: 					}
✔348: 					break;
〰349: 				case 3:
〰350: 					{
✔351: 					State = 48; bracket();
〰352: 					}
✔353: 					break;
〰354: 				case 4:
〰355: 					{
✔356: 					State = 49; filter();
〰357: 					}
✔358: 					break;
〰359: 				case 5:
〰360: 					{
✔361: 					State = 50; function();
〰362: 					}
✔363: 					break;
〰364: 				}
〰365: 				}
〰366: 				break;
〰367: 			case DESCENDANTS:
✔368: 				EnterOuterAlt(_localctx, 2);
〰369: 				{
✔370: 				State = 53; Match(DESCENDANTS);
〰371: 				}
✔372: 				break;
〰373: 			default:
‼374: 				throw new NoViableAltException(this);
〰375: 			}
✔376: 		}
‼377: 		catch (RecognitionException re) {
‼378: 			_localctx.exception = re;
‼379: 			ErrorHandler.ReportError(this, re);
‼380: 			ErrorHandler.Recover(this, re);
‼381: 		}
〰382: 		finally {
✔383: 			ExitRule();
✔384: 		}
✔385: 		return _localctx;
〰386: 	}
〰387: 
〰388: 	public partial class BracketContext : ParserRuleContext {
✔389: 		public ITerminalNode WILDCARD() { return GetToken(JsonPathParser.WILDCARD, 0); }
✔390: 		public ITerminalNode[] NUMBER() { return GetTokens(JsonPathParser.NUMBER); }
〰391: 		public ITerminalNode NUMBER(int i) {
‼392: 			return GetToken(JsonPathParser.NUMBER, i);
〰393: 		}
〰394: 		public StringContext[] @string() {
✔395: 			return GetRuleContexts<StringContext>();
〰396: 		}
〰397: 		public StringContext @string(int i) {
‼398: 			return GetRuleContext<StringContext>(i);
〰399: 		}
〰400: 		public RangeContext range() {
✔401: 			return GetRuleContext<RangeContext>(0);
〰402: 		}
〰403: 		public FunctionContext function() {
✔404: 			return GetRuleContext<FunctionContext>(0);
〰405: 		}
〰406: 		public BracketContext(ParserRuleContext parent, int invokingState)
✔407: 			: base(parent, invokingState)
〰408: 		{
✔409: 		}
‼410: 		public override int RuleIndex { get { return RULE_bracket; } }
〰411: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔412: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠413: 			if (typedVisitor != null) return typedVisitor.VisitBracket(this);
‼414: 			else return visitor.VisitChildren(this);
〰415: 		}
〰416: 	}
〰417: 
〰418: 	[RuleVersion(0)]
〰419: 	public BracketContext bracket() {
✔420: 		BracketContext _localctx = new BracketContext(Context, State);
✔421: 		EnterRule(_localctx, 10, RULE_bracket);
〰422: 		int _la;
〰423: 		try {
✔424: 			State = 88;
✔425: 			ErrorHandler.Sync(this);
⚠426: 			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
〰427: 			case 1:
✔428: 				EnterOuterAlt(_localctx, 1);
〰429: 				{
✔430: 				State = 56; Match(T__0);
✔431: 				State = 57; Match(WILDCARD);
✔432: 				State = 58; Match(T__1);
〰433: 				}
✔434: 				break;
〰435: 			case 2:
✔436: 				EnterOuterAlt(_localctx, 2);
〰437: 				{
✔438: 				State = 59; Match(T__0);
✔439: 				State = 60; Match(NUMBER);
✔440: 				State = 65;
✔441: 				ErrorHandler.Sync(this);
✔442: 				_la = TokenStream.LA(1);
✔443: 				while (_la==T__2) {
〰444: 					{
〰445: 					{
✔446: 					State = 61; Match(T__2);
✔447: 					State = 62; Match(NUMBER);
〰448: 					}
〰449: 					}
✔450: 					State = 67;
✔451: 					ErrorHandler.Sync(this);
✔452: 					_la = TokenStream.LA(1);
〰453: 				}
✔454: 				State = 68; Match(T__1);
〰455: 				}
✔456: 				break;
〰457: 			case 3:
✔458: 				EnterOuterAlt(_localctx, 3);
〰459: 				{
✔460: 				State = 69; Match(T__0);
✔461: 				State = 70; @string();
✔462: 				State = 75;
✔463: 				ErrorHandler.Sync(this);
✔464: 				_la = TokenStream.LA(1);
✔465: 				while (_la==T__2) {
〰466: 					{
〰467: 					{
✔468: 					State = 71; Match(T__2);
✔469: 					State = 72; @string();
〰470: 					}
〰471: 					}
✔472: 					State = 77;
✔473: 					ErrorHandler.Sync(this);
✔474: 					_la = TokenStream.LA(1);
〰475: 				}
✔476: 				State = 78; Match(T__1);
〰477: 				}
✔478: 				break;
〰479: 			case 4:
✔480: 				EnterOuterAlt(_localctx, 4);
〰481: 				{
✔482: 				State = 80; Match(T__0);
✔483: 				State = 81; range();
✔484: 				State = 82; Match(T__1);
〰485: 				}
✔486: 				break;
〰487: 			case 5:
‼488: 				EnterOuterAlt(_localctx, 5);
〰489: 				{
‼490: 				State = 84; Match(T__0);
‼491: 				State = 85; function();
‼492: 				State = 86; Match(T__1);
〰493: 				}
〰494: 				break;
〰495: 			}
✔496: 		}
✔497: 		catch (RecognitionException re) {
✔498: 			_localctx.exception = re;
✔499: 			ErrorHandler.ReportError(this, re);
✔500: 			ErrorHandler.Recover(this, re);
‼501: 		}
〰502: 		finally {
✔503: 			ExitRule();
✔504: 		}
✔505: 		return _localctx;
〰506: 	}
〰507: 
〰508: 	public partial class FilterContext : ParserRuleContext {
〰509: 		public QueryContext query() {
✔510: 			return GetRuleContext<QueryContext>(0);
〰511: 		}
〰512: 		public FilterContext(ParserRuleContext parent, int invokingState)
✔513: 			: base(parent, invokingState)
〰514: 		{
✔515: 		}
‼516: 		public override int RuleIndex { get { return RULE_filter; } }
〰517: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔518: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠519: 			if (typedVisitor != null) return typedVisitor.VisitFilter(this);
‼520: 			else return visitor.VisitChildren(this);
〰521: 		}
〰522: 	}
〰523: 
〰524: 	[RuleVersion(0)]
〰525: 	public FilterContext filter() {
✔526: 		FilterContext _localctx = new FilterContext(Context, State);
✔527: 		EnterRule(_localctx, 12, RULE_filter);
〰528: 		try {
✔529: 			EnterOuterAlt(_localctx, 1);
〰530: 			{
✔531: 			State = 90; Match(T__0);
✔532: 			State = 91; Match(T__3);
✔533: 			State = 92; query(0);
✔534: 			State = 93; Match(T__4);
✔535: 			State = 94; Match(T__1);
〰536: 			}
✔537: 		}
‼538: 		catch (RecognitionException re) {
‼539: 			_localctx.exception = re;
‼540: 			ErrorHandler.ReportError(this, re);
‼541: 			ErrorHandler.Recover(this, re);
‼542: 		}
〰543: 		finally {
✔544: 			ExitRule();
✔545: 		}
✔546: 		return _localctx;
〰547: 	}
〰548: 
〰549: 	public partial class RangeContext : ParserRuleContext {
〰550: 		public IToken rangeStart;
〰551: 		public IToken rangeEnd;
〰552: 		public IToken rangeStep;
‼553: 		public ITerminalNode[] NUMBER() { return GetTokens(JsonPathParser.NUMBER); }
〰554: 		public ITerminalNode NUMBER(int i) {
‼555: 			return GetToken(JsonPathParser.NUMBER, i);
〰556: 		}
〰557: 		public RangeContext(ParserRuleContext parent, int invokingState)
✔558: 			: base(parent, invokingState)
〰559: 		{
✔560: 		}
‼561: 		public override int RuleIndex { get { return RULE_range; } }
〰562: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔563: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠564: 			if (typedVisitor != null) return typedVisitor.VisitRange(this);
‼565: 			else return visitor.VisitChildren(this);
〰566: 		}
〰567: 	}
〰568: 
〰569: 	[RuleVersion(0)]
〰570: 	public RangeContext range() {
✔571: 		RangeContext _localctx = new RangeContext(Context, State);
✔572: 		EnterRule(_localctx, 14, RULE_range);
〰573: 		int _la;
〰574: 		try {
✔575: 			EnterOuterAlt(_localctx, 1);
〰576: 			{
✔577: 			State = 97;
✔578: 			ErrorHandler.Sync(this);
✔579: 			_la = TokenStream.LA(1);
✔580: 			if (_la==NUMBER) {
〰581: 				{
✔582: 				State = 96; _localctx.rangeStart = Match(NUMBER);
〰583: 				}
〰584: 			}
〰585: 
✔586: 			State = 99; Match(T__5);
✔587: 			State = 101;
✔588: 			ErrorHandler.Sync(this);
✔589: 			_la = TokenStream.LA(1);
✔590: 			if (_la==NUMBER) {
〰591: 				{
✔592: 				State = 100; _localctx.rangeEnd = Match(NUMBER);
〰593: 				}
〰594: 			}
〰595: 
✔596: 			State = 105;
✔597: 			ErrorHandler.Sync(this);
✔598: 			_la = TokenStream.LA(1);
✔599: 			if (_la==T__5) {
〰600: 				{
✔601: 				State = 103; Match(T__5);
✔602: 				State = 104; _localctx.rangeStep = Match(NUMBER);
〰603: 				}
〰604: 			}
〰605: 
〰606: 			}
✔607: 		}
‼608: 		catch (RecognitionException re) {
‼609: 			_localctx.exception = re;
‼610: 			ErrorHandler.ReportError(this, re);
‼611: 			ErrorHandler.Recover(this, re);
‼612: 		}
〰613: 		finally {
✔614: 			ExitRule();
✔615: 		}
✔616: 		return _localctx;
〰617: 	}
〰618: 
〰619: 	public partial class OperandContext : ParserRuleContext {
〰620: 		public PathContext path() {
✔621: 			return GetRuleContext<PathContext>(0);
〰622: 		}
〰623: 		public StringContext @string() {
✔624: 			return GetRuleContext<StringContext>(0);
〰625: 		}
✔626: 		public ITerminalNode NUMBER() { return GetToken(JsonPathParser.NUMBER, 0); }
〰627: 		public OperandContext(ParserRuleContext parent, int invokingState)
✔628: 			: base(parent, invokingState)
〰629: 		{
✔630: 		}
‼631: 		public override int RuleIndex { get { return RULE_operand; } }
〰632: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔633: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠634: 			if (typedVisitor != null) return typedVisitor.VisitOperand(this);
‼635: 			else return visitor.VisitChildren(this);
〰636: 		}
〰637: 	}
〰638: 
〰639: 	[RuleVersion(0)]
〰640: 	public OperandContext operand() {
✔641: 		OperandContext _localctx = new OperandContext(Context, State);
✔642: 		EnterRule(_localctx, 16, RULE_operand);
〰643: 		try {
✔644: 			State = 110;
✔645: 			ErrorHandler.Sync(this);
⚠646: 			switch (TokenStream.LA(1)) {
〰647: 			case RELATIVE:
〰648: 			case ROOT:
〰649: 			case IDENTITY:
✔650: 				EnterOuterAlt(_localctx, 1);
〰651: 				{
✔652: 				State = 107; path();
〰653: 				}
✔654: 				break;
〰655: 			case QUOTED_STRING:
✔656: 				EnterOuterAlt(_localctx, 2);
〰657: 				{
✔658: 				State = 108; @string();
〰659: 				}
✔660: 				break;
〰661: 			case NUMBER:
✔662: 				EnterOuterAlt(_localctx, 3);
〰663: 				{
✔664: 				State = 109; Match(NUMBER);
〰665: 				}
✔666: 				break;
〰667: 			default:
‼668: 				throw new NoViableAltException(this);
〰669: 			}
✔670: 		}
‼671: 		catch (RecognitionException re) {
‼672: 			_localctx.exception = re;
‼673: 			ErrorHandler.ReportError(this, re);
‼674: 			ErrorHandler.Recover(this, re);
‼675: 		}
〰676: 		finally {
✔677: 			ExitRule();
✔678: 		}
✔679: 		return _localctx;
〰680: 	}
〰681: 
〰682: 	public partial class QueryContext : ParserRuleContext {
〰683: 		public QueryContext(ParserRuleContext parent, int invokingState)
✔684: 			: base(parent, invokingState)
〰685: 		{
✔686: 		}
‼687: 		public override int RuleIndex { get { return RULE_query; } }
〰688: 
✔689: 		public QueryContext() { }
〰690: 		public virtual void CopyFrom(QueryContext context) {
✔691: 			base.CopyFrom(context);
✔692: 		}
〰693: 	}
〰694: 	public partial class QueryLogicalContext : QueryContext {
〰695: 		public QueryContext relationLeft;
〰696: 		public QueryContext relationRight;
✔697: 		public ITerminalNode LOGICAL() { return GetToken(JsonPathParser.LOGICAL, 0); }
〰698: 		public QueryContext[] query() {
‼699: 			return GetRuleContexts<QueryContext>();
〰700: 		}
〰701: 		public QueryContext query(int i) {
‼702: 			return GetRuleContext<QueryContext>(i);
〰703: 		}
✔704: 		public QueryLogicalContext(QueryContext context) { CopyFrom(context); }
〰705: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔706: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠707: 			if (typedVisitor != null) return typedVisitor.VisitQueryLogical(this);
‼708: 			else return visitor.VisitChildren(this);
〰709: 		}
〰710: 	}
〰711: 	public partial class QueryRelationalContext : QueryContext {
〰712: 		public OperandContext relationLeft;
〰713: 		public OperandContext relationRight;
✔714: 		public ITerminalNode RELATIONAL() { return GetToken(JsonPathParser.RELATIONAL, 0); }
〰715: 		public OperandContext[] operand() {
‼716: 			return GetRuleContexts<OperandContext>();
〰717: 		}
〰718: 		public OperandContext operand(int i) {
‼719: 			return GetRuleContext<OperandContext>(i);
〰720: 		}
✔721: 		public QueryRelationalContext(QueryContext context) { CopyFrom(context); }
〰722: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔723: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠724: 			if (typedVisitor != null) return typedVisitor.VisitQueryRelational(this);
‼725: 			else return visitor.VisitChildren(this);
〰726: 		}
〰727: 	}
〰728: 	public partial class QueryPathContext : QueryContext {
〰729: 		public PathContext path() {
✔730: 			return GetRuleContext<PathContext>(0);
〰731: 		}
✔732: 		public QueryPathContext(QueryContext context) { CopyFrom(context); }
〰733: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔734: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠735: 			if (typedVisitor != null) return typedVisitor.VisitQueryPath(this);
‼736: 			else return visitor.VisitChildren(this);
〰737: 		}
〰738: 	}
〰739: 
〰740: 	[RuleVersion(0)]
〰741: 	public QueryContext query() {
‼742: 		return query(0);
〰743: 	}
〰744: 
〰745: 	private QueryContext query(int _p) {
✔746: 		ParserRuleContext _parentctx = Context;
✔747: 		int _parentState = State;
✔748: 		QueryContext _localctx = new QueryContext(Context, _parentState);
✔749: 		QueryContext _prevctx = _localctx;
✔750: 		int _startState = 18;
✔751: 		EnterRecursionRule(_localctx, 18, RULE_query, _p);
〰752: 		try {
〰753: 			int _alt;
✔754: 			EnterOuterAlt(_localctx, 1);
〰755: 			{
✔756: 			State = 118;
✔757: 			ErrorHandler.Sync(this);
✔758: 			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
〰759: 			case 1:
〰760: 				{
✔761: 				_localctx = new QueryPathContext(_localctx);
✔762: 				Context = _localctx;
✔763: 				_prevctx = _localctx;
〰764: 
✔765: 				State = 113; path();
〰766: 				}
✔767: 				break;
〰768: 			case 2:
〰769: 				{
✔770: 				_localctx = new QueryRelationalContext(_localctx);
✔771: 				Context = _localctx;
✔772: 				_prevctx = _localctx;
✔773: 				State = 114; ((QueryRelationalContext)_localctx).relationLeft = operand();
✔774: 				State = 115; Match(RELATIONAL);
✔775: 				State = 116; ((QueryRelationalContext)_localctx).relationRight = operand();
〰776: 				}
〰777: 				break;
〰778: 			}
✔779: 			Context.Stop = TokenStream.LT(-1);
✔780: 			State = 125;
✔781: 			ErrorHandler.Sync(this);
✔782: 			_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
✔783: 			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
✔784: 				if ( _alt==1 ) {
✔785: 					if ( ParseListeners!=null )
✔786: 						TriggerExitRuleEvent();
✔787: 					_prevctx = _localctx;
〰788: 					{
〰789: 					{
✔790: 					_localctx = new QueryLogicalContext(new QueryContext(_parentctx, _parentState));
✔791: 					((QueryLogicalContext)_localctx).relationLeft = _prevctx;
✔792: 					PushNewRecursionContext(_localctx, _startState, RULE_query);
✔793: 					State = 120;
‼794: 					if (!(Precpred(Context, 1))) throw new FailedPredicateException(this, "Precpred(Context, 1)");
✔795: 					State = 121; Match(LOGICAL);
✔796: 					State = 122; ((QueryLogicalContext)_localctx).relationRight = query(2);
〰797: 					}
〰798: 					}
〰799: 				}
✔800: 				State = 127;
✔801: 				ErrorHandler.Sync(this);
✔802: 				_alt = Interpreter.AdaptivePredict(TokenStream,13,Context);
〰803: 			}
〰804: 			}
✔805: 		}
‼806: 		catch (RecognitionException re) {
‼807: 			_localctx.exception = re;
‼808: 			ErrorHandler.ReportError(this, re);
‼809: 			ErrorHandler.Recover(this, re);
‼810: 		}
〰811: 		finally {
✔812: 			UnrollRecursionContexts(_parentctx);
✔813: 		}
✔814: 		return _localctx;
〰815: 	}
〰816: 
〰817: 	public partial class IdentityContext : ParserRuleContext {
✔818: 		public ITerminalNode IDENTITY() { return GetToken(JsonPathParser.IDENTITY, 0); }
〰819: 		public IdentityContext(ParserRuleContext parent, int invokingState)
✔820: 			: base(parent, invokingState)
〰821: 		{
✔822: 		}
‼823: 		public override int RuleIndex { get { return RULE_identity; } }
〰824: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔825: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠826: 			if (typedVisitor != null) return typedVisitor.VisitIdentity(this);
‼827: 			else return visitor.VisitChildren(this);
〰828: 		}
〰829: 	}
〰830: 
〰831: 	[RuleVersion(0)]
〰832: 	public IdentityContext identity() {
✔833: 		IdentityContext _localctx = new IdentityContext(Context, State);
✔834: 		EnterRule(_localctx, 20, RULE_identity);
〰835: 		try {
✔836: 			EnterOuterAlt(_localctx, 1);
〰837: 			{
✔838: 			State = 128; Match(IDENTITY);
〰839: 			}
✔840: 		}
‼841: 		catch (RecognitionException re) {
‼842: 			_localctx.exception = re;
‼843: 			ErrorHandler.ReportError(this, re);
‼844: 			ErrorHandler.Recover(this, re);
‼845: 		}
〰846: 		finally {
✔847: 			ExitRule();
✔848: 		}
✔849: 		return _localctx;
〰850: 	}
〰851: 
〰852: 	public partial class StringContext : ParserRuleContext {
✔853: 		public ITerminalNode QUOTED_STRING() { return GetToken(JsonPathParser.QUOTED_STRING, 0); }
〰854: 		public StringContext(ParserRuleContext parent, int invokingState)
✔855: 			: base(parent, invokingState)
〰856: 		{
✔857: 		}
‼858: 		public override int RuleIndex { get { return RULE_string; } }
〰859: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔860: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠861: 			if (typedVisitor != null) return typedVisitor.VisitString(this);
‼862: 			else return visitor.VisitChildren(this);
〰863: 		}
〰864: 	}
〰865: 
〰866: 	[RuleVersion(0)]
〰867: 	public StringContext @string() {
✔868: 		StringContext _localctx = new StringContext(Context, State);
✔869: 		EnterRule(_localctx, 22, RULE_string);
〰870: 		try {
✔871: 			EnterOuterAlt(_localctx, 1);
〰872: 			{
✔873: 			State = 130; Match(QUOTED_STRING);
〰874: 			}
✔875: 		}
‼876: 		catch (RecognitionException re) {
‼877: 			_localctx.exception = re;
‼878: 			ErrorHandler.ReportError(this, re);
‼879: 			ErrorHandler.Recover(this, re);
‼880: 		}
〰881: 		finally {
✔882: 			ExitRule();
✔883: 		}
✔884: 		return _localctx;
〰885: 	}
〰886: 
〰887: 	public partial class FunctionContext : ParserRuleContext {
〰888: 		public IdentityContext identity() {
✔889: 			return GetRuleContext<IdentityContext>(0);
〰890: 		}
〰891: 		public FunctionParameterContext[] functionParameter() {
✔892: 			return GetRuleContexts<FunctionParameterContext>();
〰893: 		}
〰894: 		public FunctionParameterContext functionParameter(int i) {
‼895: 			return GetRuleContext<FunctionParameterContext>(i);
〰896: 		}
〰897: 		public FunctionContext(ParserRuleContext parent, int invokingState)
✔898: 			: base(parent, invokingState)
〰899: 		{
✔900: 		}
‼901: 		public override int RuleIndex { get { return RULE_function; } }
〰902: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔903: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠904: 			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
‼905: 			else return visitor.VisitChildren(this);
〰906: 		}
〰907: 	}
〰908: 
〰909: 	[RuleVersion(0)]
〰910: 	public FunctionContext function() {
✔911: 		FunctionContext _localctx = new FunctionContext(Context, State);
✔912: 		EnterRule(_localctx, 24, RULE_function);
〰913: 		int _la;
〰914: 		try {
✔915: 			State = 147;
✔916: 			ErrorHandler.Sync(this);
✔917: 			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
〰918: 			case 1:
✔919: 				EnterOuterAlt(_localctx, 1);
〰920: 				{
✔921: 				State = 132; identity();
✔922: 				State = 133; Match(T__6);
〰923: 				}
✔924: 				break;
〰925: 			case 2:
✔926: 				EnterOuterAlt(_localctx, 2);
〰927: 				{
✔928: 				State = 135; identity();
✔929: 				State = 136; Match(T__7);
✔930: 				State = 137; functionParameter();
✔931: 				State = 142;
✔932: 				ErrorHandler.Sync(this);
✔933: 				_la = TokenStream.LA(1);
✔934: 				while (_la==T__2) {
〰935: 					{
〰936: 					{
✔937: 					State = 138; Match(T__2);
✔938: 					State = 139; functionParameter();
〰939: 					}
〰940: 					}
✔941: 					State = 144;
✔942: 					ErrorHandler.Sync(this);
✔943: 					_la = TokenStream.LA(1);
〰944: 				}
✔945: 				State = 145; Match(T__4);
〰946: 				}
〰947: 				break;
〰948: 			}
✔949: 		}
‼950: 		catch (RecognitionException re) {
‼951: 			_localctx.exception = re;
‼952: 			ErrorHandler.ReportError(this, re);
‼953: 			ErrorHandler.Recover(this, re);
‼954: 		}
〰955: 		finally {
✔956: 			ExitRule();
✔957: 		}
✔958: 		return _localctx;
〰959: 	}
〰960: 
〰961: 	public partial class FunctionParameterContext : ParserRuleContext {
〰962: 		public OperandContext operand() {
✔963: 			return GetRuleContext<OperandContext>(0);
〰964: 		}
〰965: 		public PathBaseContext pathBase() {
✔966: 			return GetRuleContext<PathBaseContext>(0);
〰967: 		}
✔968: 		public ITerminalNode DECIMAL() { return GetToken(JsonPathParser.DECIMAL, 0); }
〰969: 		public FunctionParameterContext(ParserRuleContext parent, int invokingState)
✔970: 			: base(parent, invokingState)
〰971: 		{
✔972: 		}
‼973: 		public override int RuleIndex { get { return RULE_functionParameter; } }
〰974: 		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
✔975: 			IJsonPathVisitor<TResult> typedVisitor = visitor as IJsonPathVisitor<TResult>;
⚠976: 			if (typedVisitor != null) return typedVisitor.VisitFunctionParameter(this);
‼977: 			else return visitor.VisitChildren(this);
〰978: 		}
〰979: 	}
〰980: 
〰981: 	[RuleVersion(0)]
〰982: 	public FunctionParameterContext functionParameter() {
✔983: 		FunctionParameterContext _localctx = new FunctionParameterContext(Context, State);
✔984: 		EnterRule(_localctx, 26, RULE_functionParameter);
〰985: 		try {
✔986: 			State = 152;
✔987: 			ErrorHandler.Sync(this);
✔988: 			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
〰989: 			case 1:
✔990: 				EnterOuterAlt(_localctx, 1);
〰991: 				{
✔992: 				State = 149; operand();
〰993: 				}
✔994: 				break;
〰995: 			case 2:
✔996: 				EnterOuterAlt(_localctx, 2);
〰997: 				{
✔998: 				State = 150; pathBase();
〰999: 				}
✔1000:				break;
〰1001:			case 3:
✔1002:				EnterOuterAlt(_localctx, 3);
〰1003:				{
✔1004:				State = 151; Match(DECIMAL);
〰1005:				}
〰1006:				break;
〰1007:			}
✔1008:		}
‼1009:		catch (RecognitionException re) {
‼1010:			_localctx.exception = re;
‼1011:			ErrorHandler.ReportError(this, re);
‼1012:			ErrorHandler.Recover(this, re);
‼1013:		}
〰1014:		finally {
✔1015:			ExitRule();
✔1016:		}
✔1017:		return _localctx;
〰1018:	}
〰1019:
〰1020:	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
〰1021:		switch (ruleIndex) {
‼1022:		case 9: return query_sempred((QueryContext)_localctx, predIndex);
〰1023:		}
‼1024:		return true;
〰1025:	}
〰1026:	private bool query_sempred(QueryContext _localctx, int predIndex) {
〰1027:		switch (predIndex) {
‼1028:		case 0: return Precpred(Context, 1);
〰1029:		}
‼1030:		return true;
〰1031:	}
〰1032:
✔1033:	private static char[] _serializedATN = {
✔1034:		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786',
✔1035:		'\x5964', '\x3', '\x16', '\x9D', '\x4', '\x2', '\t', '\x2', '\x4', '\x3',
✔1036:		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4',
✔1037:		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b',
✔1038:		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v',
✔1039:		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t',
✔1040:		'\xE', '\x4', '\xF', '\t', '\xF', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2',
✔1041:		'\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x5', '\x3',
✔1042:		'&', '\n', '\x3', '\x3', '\x4', '\x3', '\x4', '\x3', '\x5', '\x3', '\x5',
✔1043:		'\x5', '\x5', ',', '\n', '\x5', '\x3', '\x6', '\x5', '\x6', '/', '\n',
✔1044:		'\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3',
✔1045:		'\x6', '\x5', '\x6', '\x36', '\n', '\x6', '\x3', '\x6', '\x5', '\x6',
✔1046:		'\x39', '\n', '\x6', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a',
✔1047:		'\x3', '\a', '\x3', '\a', '\x3', '\a', '\a', '\a', '\x42', '\n', '\a',
✔1048:		'\f', '\a', '\xE', '\a', '\x45', '\v', '\a', '\x3', '\a', '\x3', '\a',
✔1049:		'\x3', '\a', '\x3', '\a', '\x3', '\a', '\a', '\a', 'L', '\n', '\a', '\f',
✔1050:		'\a', '\xE', '\a', 'O', '\v', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a',
✔1051:		'\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3', '\a', '\x3',
✔1052:		'\a', '\x3', '\a', '\x5', '\a', '[', '\n', '\a', '\x3', '\b', '\x3', '\b',
✔1053:		'\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\t', '\x5',
✔1054:		'\t', '\x64', '\n', '\t', '\x3', '\t', '\x3', '\t', '\x5', '\t', 'h',
✔1055:		'\n', '\t', '\x3', '\t', '\x3', '\t', '\x5', '\t', 'l', '\n', '\t', '\x3',
✔1056:		'\n', '\x3', '\n', '\x3', '\n', '\x5', '\n', 'q', '\n', '\n', '\x3', '\v',
✔1057:		'\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x5',
✔1058:		'\v', 'y', '\n', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\a', '\v',
✔1059:		'~', '\n', '\v', '\f', '\v', '\xE', '\v', '\x81', '\v', '\v', '\x3', '\f',
✔1060:		'\x3', '\f', '\x3', '\r', '\x3', '\r', '\x3', '\xE', '\x3', '\xE', '\x3',
✔1061:		'\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x3',
✔1062:		'\xE', '\a', '\xE', '\x8F', '\n', '\xE', '\f', '\xE', '\xE', '\xE', '\x92',
✔1063:		'\v', '\xE', '\x3', '\xE', '\x3', '\xE', '\x5', '\xE', '\x96', '\n', '\xE',
✔1064:		'\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x5', '\xF', '\x9B', '\n',
✔1065:		'\xF', '\x3', '\xF', '\x2', '\x3', '\x14', '\x10', '\x2', '\x4', '\x6',
✔1066:		'\b', '\n', '\f', '\xE', '\x10', '\x12', '\x14', '\x16', '\x18', '\x1A',
✔1067:		'\x1C', '\x2', '\x3', '\x3', '\x2', '\x11', '\x12', '\x2', '\xA7', '\x2',
✔1068:		'\x1E', '\x3', '\x2', '\x2', '\x2', '\x4', '%', '\x3', '\x2', '\x2', '\x2',
✔1069:		'\x6', '\'', '\x3', '\x2', '\x2', '\x2', '\b', ')', '\x3', '\x2', '\x2',
✔1070:		'\x2', '\n', '\x38', '\x3', '\x2', '\x2', '\x2', '\f', 'Z', '\x3', '\x2',
✔1071:		'\x2', '\x2', '\xE', '\\', '\x3', '\x2', '\x2', '\x2', '\x10', '\x63',
✔1072:		'\x3', '\x2', '\x2', '\x2', '\x12', 'p', '\x3', '\x2', '\x2', '\x2', '\x14',
✔1073:		'x', '\x3', '\x2', '\x2', '\x2', '\x16', '\x82', '\x3', '\x2', '\x2',
✔1074:		'\x2', '\x18', '\x84', '\x3', '\x2', '\x2', '\x2', '\x1A', '\x95', '\x3',
✔1075:		'\x2', '\x2', '\x2', '\x1C', '\x9A', '\x3', '\x2', '\x2', '\x2', '\x1E',
✔1076:		'\x1F', '\x5', '\x4', '\x3', '\x2', '\x1F', ' ', '\a', '\x2', '\x2', '\x3',
✔1077:		' ', '\x3', '\x3', '\x2', '\x2', '\x2', '!', '\"', '\x5', '\x6', '\x4',
✔1078:		'\x2', '\"', '#', '\x5', '\b', '\x5', '\x2', '#', '&', '\x3', '\x2', '\x2',
✔1079:		'\x2', '$', '&', '\x5', '\x1A', '\xE', '\x2', '%', '!', '\x3', '\x2',
✔1080:		'\x2', '\x2', '%', '$', '\x3', '\x2', '\x2', '\x2', '&', '\x5', '\x3',
✔1081:		'\x2', '\x2', '\x2', '\'', '(', '\t', '\x2', '\x2', '\x2', '(', '\a',
✔1082:		'\x3', '\x2', '\x2', '\x2', ')', '+', '\x5', '\n', '\x6', '\x2', '*',
✔1083:		',', '\x5', '\b', '\x5', '\x2', '+', '*', '\x3', '\x2', '\x2', '\x2',
✔1084:		'+', ',', '\x3', '\x2', '\x2', '\x2', ',', '\t', '\x3', '\x2', '\x2',
✔1085:		'\x2', '-', '/', '\a', '\xE', '\x2', '\x2', '.', '-', '\x3', '\x2', '\x2',
✔1086:		'\x2', '.', '/', '\x3', '\x2', '\x2', '\x2', '/', '\x35', '\x3', '\x2',
✔1087:		'\x2', '\x2', '\x30', '\x36', '\a', '\xF', '\x2', '\x2', '\x31', '\x36',
✔1088:		'\x5', '\x16', '\f', '\x2', '\x32', '\x36', '\x5', '\f', '\a', '\x2',
✔1089:		'\x33', '\x36', '\x5', '\xE', '\b', '\x2', '\x34', '\x36', '\x5', '\x1A',
✔1090:		'\xE', '\x2', '\x35', '\x30', '\x3', '\x2', '\x2', '\x2', '\x35', '\x31',
✔1091:		'\x3', '\x2', '\x2', '\x2', '\x35', '\x32', '\x3', '\x2', '\x2', '\x2',
✔1092:		'\x35', '\x33', '\x3', '\x2', '\x2', '\x2', '\x35', '\x34', '\x3', '\x2',
✔1093:		'\x2', '\x2', '\x36', '\x39', '\x3', '\x2', '\x2', '\x2', '\x37', '\x39',
✔1094:		'\a', '\x10', '\x2', '\x2', '\x38', '.', '\x3', '\x2', '\x2', '\x2', '\x38',
✔1095:		'\x37', '\x3', '\x2', '\x2', '\x2', '\x39', '\v', '\x3', '\x2', '\x2',
✔1096:		'\x2', ':', ';', '\a', '\x3', '\x2', '\x2', ';', '<', '\a', '\xF', '\x2',
✔1097:		'\x2', '<', '[', '\a', '\x4', '\x2', '\x2', '=', '>', '\a', '\x3', '\x2',
✔1098:		'\x2', '>', '\x43', '\a', '\x14', '\x2', '\x2', '?', '@', '\a', '\x5',
✔1099:		'\x2', '\x2', '@', '\x42', '\a', '\x14', '\x2', '\x2', '\x41', '?', '\x3',
✔1100:		'\x2', '\x2', '\x2', '\x42', '\x45', '\x3', '\x2', '\x2', '\x2', '\x43',
✔1101:		'\x41', '\x3', '\x2', '\x2', '\x2', '\x43', '\x44', '\x3', '\x2', '\x2',
✔1102:		'\x2', '\x44', '\x46', '\x3', '\x2', '\x2', '\x2', '\x45', '\x43', '\x3',
✔1103:		'\x2', '\x2', '\x2', '\x46', '[', '\a', '\x4', '\x2', '\x2', 'G', 'H',
✔1104:		'\a', '\x3', '\x2', '\x2', 'H', 'M', '\x5', '\x18', '\r', '\x2', 'I',
✔1105:		'J', '\a', '\x5', '\x2', '\x2', 'J', 'L', '\x5', '\x18', '\r', '\x2',
✔1106:		'K', 'I', '\x3', '\x2', '\x2', '\x2', 'L', 'O', '\x3', '\x2', '\x2', '\x2',
✔1107:		'M', 'K', '\x3', '\x2', '\x2', '\x2', 'M', 'N', '\x3', '\x2', '\x2', '\x2',
✔1108:		'N', 'P', '\x3', '\x2', '\x2', '\x2', 'O', 'M', '\x3', '\x2', '\x2', '\x2',
✔1109:		'P', 'Q', '\a', '\x4', '\x2', '\x2', 'Q', '[', '\x3', '\x2', '\x2', '\x2',
✔1110:		'R', 'S', '\a', '\x3', '\x2', '\x2', 'S', 'T', '\x5', '\x10', '\t', '\x2',
✔1111:		'T', 'U', '\a', '\x4', '\x2', '\x2', 'U', '[', '\x3', '\x2', '\x2', '\x2',
✔1112:		'V', 'W', '\a', '\x3', '\x2', '\x2', 'W', 'X', '\x5', '\x1A', '\xE', '\x2',
✔1113:		'X', 'Y', '\a', '\x4', '\x2', '\x2', 'Y', '[', '\x3', '\x2', '\x2', '\x2',
✔1114:		'Z', ':', '\x3', '\x2', '\x2', '\x2', 'Z', '=', '\x3', '\x2', '\x2', '\x2',
✔1115:		'Z', 'G', '\x3', '\x2', '\x2', '\x2', 'Z', 'R', '\x3', '\x2', '\x2', '\x2',
✔1116:		'Z', 'V', '\x3', '\x2', '\x2', '\x2', '[', '\r', '\x3', '\x2', '\x2',
✔1117:		'\x2', '\\', ']', '\a', '\x3', '\x2', '\x2', ']', '^', '\a', '\x6', '\x2',
✔1118:		'\x2', '^', '_', '\x5', '\x14', '\v', '\x2', '_', '`', '\a', '\a', '\x2',
✔1119:		'\x2', '`', '\x61', '\a', '\x4', '\x2', '\x2', '\x61', '\xF', '\x3', '\x2',
✔1120:		'\x2', '\x2', '\x62', '\x64', '\a', '\x14', '\x2', '\x2', '\x63', '\x62',
✔1121:		'\x3', '\x2', '\x2', '\x2', '\x63', '\x64', '\x3', '\x2', '\x2', '\x2',
✔1122:		'\x64', '\x65', '\x3', '\x2', '\x2', '\x2', '\x65', 'g', '\a', '\b', '\x2',
✔1123:		'\x2', '\x66', 'h', '\a', '\x14', '\x2', '\x2', 'g', '\x66', '\x3', '\x2',
✔1124:		'\x2', '\x2', 'g', 'h', '\x3', '\x2', '\x2', '\x2', 'h', 'k', '\x3', '\x2',
✔1125:		'\x2', '\x2', 'i', 'j', '\a', '\b', '\x2', '\x2', 'j', 'l', '\a', '\x14',
✔1126:		'\x2', '\x2', 'k', 'i', '\x3', '\x2', '\x2', '\x2', 'k', 'l', '\x3', '\x2',
✔1127:		'\x2', '\x2', 'l', '\x11', '\x3', '\x2', '\x2', '\x2', 'm', 'q', '\x5',
✔1128:		'\x4', '\x3', '\x2', 'n', 'q', '\x5', '\x18', '\r', '\x2', 'o', 'q', '\a',
✔1129:		'\x14', '\x2', '\x2', 'p', 'm', '\x3', '\x2', '\x2', '\x2', 'p', 'n',
✔1130:		'\x3', '\x2', '\x2', '\x2', 'p', 'o', '\x3', '\x2', '\x2', '\x2', 'q',
✔1131:		'\x13', '\x3', '\x2', '\x2', '\x2', 'r', 's', '\b', '\v', '\x1', '\x2',
✔1132:		's', 'y', '\x5', '\x4', '\x3', '\x2', 't', 'u', '\x5', '\x12', '\n', '\x2',
✔1133:		'u', 'v', '\a', '\r', '\x2', '\x2', 'v', 'w', '\x5', '\x12', '\n', '\x2',
✔1134:		'w', 'y', '\x3', '\x2', '\x2', '\x2', 'x', 'r', '\x3', '\x2', '\x2', '\x2',
✔1135:		'x', 't', '\x3', '\x2', '\x2', '\x2', 'y', '\x7F', '\x3', '\x2', '\x2',
✔1136:		'\x2', 'z', '{', '\f', '\x3', '\x2', '\x2', '{', '|', '\a', '\f', '\x2',
✔1137:		'\x2', '|', '~', '\x5', '\x14', '\v', '\x4', '}', 'z', '\x3', '\x2', '\x2',
✔1138:		'\x2', '~', '\x81', '\x3', '\x2', '\x2', '\x2', '\x7F', '}', '\x3', '\x2',
✔1139:		'\x2', '\x2', '\x7F', '\x80', '\x3', '\x2', '\x2', '\x2', '\x80', '\x15',
✔1140:		'\x3', '\x2', '\x2', '\x2', '\x81', '\x7F', '\x3', '\x2', '\x2', '\x2',
✔1141:		'\x82', '\x83', '\a', '\x13', '\x2', '\x2', '\x83', '\x17', '\x3', '\x2',
✔1142:		'\x2', '\x2', '\x84', '\x85', '\a', '\v', '\x2', '\x2', '\x85', '\x19',
✔1143:		'\x3', '\x2', '\x2', '\x2', '\x86', '\x87', '\x5', '\x16', '\f', '\x2',
✔1144:		'\x87', '\x88', '\a', '\t', '\x2', '\x2', '\x88', '\x96', '\x3', '\x2',
✔1145:		'\x2', '\x2', '\x89', '\x8A', '\x5', '\x16', '\f', '\x2', '\x8A', '\x8B',
✔1146:		'\a', '\n', '\x2', '\x2', '\x8B', '\x90', '\x5', '\x1C', '\xF', '\x2',
✔1147:		'\x8C', '\x8D', '\a', '\x5', '\x2', '\x2', '\x8D', '\x8F', '\x5', '\x1C',
✔1148:		'\xF', '\x2', '\x8E', '\x8C', '\x3', '\x2', '\x2', '\x2', '\x8F', '\x92',
✔1149:		'\x3', '\x2', '\x2', '\x2', '\x90', '\x8E', '\x3', '\x2', '\x2', '\x2',
✔1150:		'\x90', '\x91', '\x3', '\x2', '\x2', '\x2', '\x91', '\x93', '\x3', '\x2',
✔1151:		'\x2', '\x2', '\x92', '\x90', '\x3', '\x2', '\x2', '\x2', '\x93', '\x94',
✔1152:		'\a', '\a', '\x2', '\x2', '\x94', '\x96', '\x3', '\x2', '\x2', '\x2',
✔1153:		'\x95', '\x86', '\x3', '\x2', '\x2', '\x2', '\x95', '\x89', '\x3', '\x2',
✔1154:		'\x2', '\x2', '\x96', '\x1B', '\x3', '\x2', '\x2', '\x2', '\x97', '\x9B',
✔1155:		'\x5', '\x12', '\n', '\x2', '\x98', '\x9B', '\x5', '\x6', '\x4', '\x2',
✔1156:		'\x99', '\x9B', '\a', '\x15', '\x2', '\x2', '\x9A', '\x97', '\x3', '\x2',
✔1157:		'\x2', '\x2', '\x9A', '\x98', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x99',
✔1158:		'\x3', '\x2', '\x2', '\x2', '\x9B', '\x1D', '\x3', '\x2', '\x2', '\x2',
✔1159:		'\x13', '%', '+', '.', '\x35', '\x38', '\x43', 'M', 'Z', '\x63', 'g',
✔1160:		'k', 'p', 'x', '\x7F', '\x90', '\x95', '\x9A',
✔1161:	};
〰1162:
✔1163:	public static readonly ATN _ATN =
✔1164:		new ATNDeserializer().Deserialize(_serializedATN);
〰1165:
〰1166:
〰1167:}
```

## Links

* [Return to Summary](Summary.md)
* [Table of Contents](../TOC.md)

